## 贪心

根据「交替数组」的定义，我们可以将数组根据下标奇偶性分成两个序列，最终目的是：**使用最少的修改次数，使得「两个序列均成为公差为 $0$ 等差数列」，同时「两序列的首项不相等」。**

要用最少次数将一个序列修改为公差为 $0$ 等差数列，等价于修改最少的数字，等价于保留最多的数字，容易想到将序列中的其他「非众数」修改为「众数」（若有多个众数，取任一）。

而单纯对两个序列执行上述逻辑，并不能确保最终得到的是「交替数组」，即未必满足「两序列的首项不相等」的要求。

因此我们可以对 $nums$ 进行扫描，分别统计「偶数下标序列」和「奇数下标序列」的最大值（众数）和次大值（**注意是非严格的次大值，即为「其他众数」或者「出现次数比众数小的数」**），使用 `a` 和 `b` 代指「偶数下标序列」的最大值和次大值，使用 `c` 和 `d` 代指「奇数下标序列」的最大值和次大值。同时使用 `m1` 和 `m2` 分别统计「偶数下标序列」和「奇数下标序列」中某个数的出现次数。

根据两序列的最大值是否冲突进行分情况讨论：

* 若两序列的最大值不冲突（$a\neq c$）：那么两序列都可以取得最小修改次数（保留最大值），整体的最小修改次数为 $n - m1[a] - m2[c]$ ；
* 若两序列的最大值冲突（$a\ = c$）：那么仅一序列可以取得最小修改次数（保留最大值），另一序列只能取得“次小”的修改次数（保留次大值），此时整体的最小修改次数为 $n - \max(m1[a] + m2[d], m1[b] + m2[c])$。

代码：

* []

```Java
class Solution {
    static int N = 100010;
    static int[] m1 = new int[N], m2 = new int[N];
    public int minimumOperations(int[] nums) {
        int n = nums.length;
        Arrays.fill(m1, 0);
        Arrays.fill(m2, 0);
        int a = 0, b = 0, c = 0, d = 0;
        for (int i = 0; i < n; i++) {
            int t = nums[i];
            if (i % 2 == 0) {
                m1[t]++;
                if (a == 0 || m1[t] > m1[a]) {
                    b = a; a = t;
                } else if (t != a && (b == 0 || m1[t] > m1[b])) {
                    b = t;
                }
            } else {
                m2[t]++;
                if (c == 0 || m2[t] > m2[c]) {
                    d = c; c = t;
                } else if (t != c && (d == 0 || m2[t] > m2[d])) {
                    d = t;
                }
            }
        }
        if (a != c) return n - m1[a] - m2[c];
        else return n - Math.max(m1[a] + m2[d], m1[b] + m2[c]);
    }
}
```

* 时间复杂度：$O(n)$
* 空间复杂度：$O(C)$

---

## 最后

**如果有帮助到你，请给题解点个赞和收藏，让更多的人看到 ~ ("▔□▔)/**

也欢迎你 [关注我](https://oscimg.oschina.net/oscnet/up-19688dc1af05cf8bdea43b2a863038ab9e5.png) 和 加入我们的[「组队打卡」](https://leetcode-cn.com/u/ac_oier/)小群 ，提供写「证明」&「思路」的高质量题解。

所有题解已经加入 [刷题指南](https://github.com/SharingSource/LogicStack-LeetCode/wiki)，欢迎 star 哦 ~
