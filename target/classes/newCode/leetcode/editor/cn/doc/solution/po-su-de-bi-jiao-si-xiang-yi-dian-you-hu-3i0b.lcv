首先我们不难想到本题所求的子串一定是原串的后缀，因为给一个字符串的末尾加上任意字符后，它的字典序一定比原串更大。那么熟悉后缀系列数据结构的同学就可以直接套板子了。

但是我们如果不使用这些现成的算法应该怎么做呢？

&nbsp;

有一个很朴素的想法是，我们先找到这个字符串中所有最大的字符，然后看这些字符的下一位，把这一位里不是最大的都剔除出答案的候选集合，然后再看下一位，直到比较结束。

例如，有一个串是tabtadt，最大的字符是第0个t、第3个t和第6个t，我们先将他们都加入答案的候选集。

接下来我们查看t的后一位，那么三个候选答案分别变成了ta、ta和t。那么最后一个t的这一位是空，不是最大的，因而不可能是最终答案，将它剔除。

再查看a的后一位，两个候选答案的这一位是b和d，d更大，因此剔除掉从0开始的tab。

此时候选答案只剩下唯一的tad，因此最终答案就是从第3个t开始的tadt。

&nbsp;

这个方法看起来解决了问题，但我们很快就能想到这样一个反例：babababababa...，或者更暴力一点的aaaaaaaaaaaaaaaa...。对于这样的字符串，我们的朴素做法的时间复杂度显然会退化到$O(N^2)$，这是不能接受的。

其实，对于这样的例子，我们不难发现是我们多次扫描了同一个字符，导致我们的时间复杂度急剧上升。有没有办法利用到这些结果呢？

&nbsp;

我们就以babababa为例子。第一次，我们有4个候选答案；往后扫描一个字符时，候选答案数量并没有减少；再往后扫描一个字符时，对于仍在候选答案集里的前3个bab中实际上已经出现了重复扫描。此时我们已经完整地查看过全部的字符串了，这里面其实隐藏了一些很重要的信息，那就是目前字符串的一部分的形式是 **已扫描串+已扫描串+...+已扫描串+首字母** 。而对于这样形式的串，可以得到的结论是，在这一部分中，其实**只有首字母开始的后缀才是真正的可能作为答案的后缀**！

&nbsp;

我们代入例子来看，对于串babababa，我们向后查看2次，此时已扫描的串是bab，候选答案集中存在相互覆盖的情况。

对于首字母来说，它已知的信息是之后的部分为babab?????（???表示我们因为还没扫描而不清楚之后的信息），而对于答案候选集中被它扫描到的bab，它已知的部分是bab??????。比较字符串的时候需要从头开始，我们将它对齐看看：

&nbsp;

babab???????
bab???????

&nbsp;

似乎我们无法比较bab??????和b???????。但是不要忘了，现在bab??????在候选答案集里，而b???????可不在候选集里，这说明什么？说明在之前的筛选过程中，我们已经知道了b????????的字典序小于bab????????，因此babab????????一定大于bab????????

&nbsp;

如果这个b??????仍然在答案候选集里，也不要紧，因为我们可以把这个比较方法继续往它身上套。在babababa这个例子中，我们最终的比较链条为：

bababab???  $从第0个b开始$
babab???    $从第2个b开始$
bab???      $从第4个b开始$
ba          $从第6个b开始，已经被剔除出候选集合$

即便这个链条中存在多个候选答案，但它总有一个结尾，这个结尾的字符串一定是以相同的首字母开始，且已经被剔除出了候选集合，因此我们得知这些“候选答案”的字典序是递减的，只有从第一个字母开始的候选答案才是真正的候选答案！

&nbsp;

此时，对于原串的每一个字符，我们应该不会扫描它超过2次，因此在$O(N)$时间就解决了这个问题。当然我们还可以进一步优化到用双扫描指针来解决此问题，这个其他题解已经很多，就不赘述了。

* C++

```C++
class Solution {
public:
    string lastSubstring(string s) 
    {
        int n = s.length();

        char maxch = 0;
        for(auto i : s)
            maxch = max(i , maxch);
        
        // 储存候选答案的开始位置
        vector<int> q , r;
        // 标记是否为候选答案
        bool maybe[400010] = {0};
        for(int i = 0 ; i < n ; i++)
            if(s[i] == maxch)
            {
                q.push_back(i);
                maybe[i] = 1;
            }
        
        // 已扫描的长度
        int maxlength = 1;
        for( ; q.size() > 1 ; )
        {
            char maxNextCh = 0;
            for(auto j : q)
                if(j + maxlength < n)
                    maxNextCh = max(maxNextCh , s[j + maxlength]);
            
            r.clear();
            for(auto j : q)
            {
                // 可能是被之前候选答案覆盖到的部分，不需要再进行判断了
                if(!maybe[j]) continue;
                // 当前扫描位不是最大字符，直接剔除
                if(j + maxlength >= n || s[j + maxlength] != maxNextCh)
                {
                    maybe[j] = 0;
                    continue;
                }
                r.push_back(j);
                // 可能扫到其他的候选答案
                if(maxNextCh == maxch)
                {
                    // 对于相连的候选答案，拍在后面的不可能为最终答案，直接剔除
                    int now = j + maxlength;
                    while(now < n && maybe[now])
                    {
                        maybe[now] = 0;
                        now += maxlength;
                    }
                }
            }
            swap(q , r);
            maxlength++;
        }

        return s.substr(q[0]);
    }
};
```

