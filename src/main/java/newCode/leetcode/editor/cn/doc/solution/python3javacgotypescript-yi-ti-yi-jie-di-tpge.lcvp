**æ–¹æ³•ä¸€ï¼šé€’å½’å›žæº¯ + çŠ¶æ€åŽ‹ç¼©**

æˆ‘ä»¬å¯ä»¥æŒ‰ä½ç½®è¿›è¡Œé€’å½’å›žæº¯ï¼Œè¿‡ç¨‹ä¸­æˆ‘ä»¬ç”¨ä¸€ä¸ªå˜é‡ $t$ è®°å½•å½“å‰ä½¿ç”¨çš„ç“·ç –æ•°ã€‚

- å¦‚æžœ $j = m$ï¼Œå³ç¬¬ $i$ è¡Œå·²ç»è¢«å®Œå…¨å¡«å……ï¼Œåˆ™é€’å½’åˆ°ä¸‹ä¸€è¡Œï¼Œå³ $(i + 1, 0)$ã€‚
- å¦‚æžœ $i = n$ï¼Œåˆ™è¡¨ç¤ºæ‰€æœ‰ä½ç½®éƒ½å·²ç»è¢«å¡«å……ï¼Œæˆ‘ä»¬æ›´æ–°ç­”æ¡ˆå¹¶è¿”å›žã€‚
- å¦‚æžœå½“å‰ä½ç½® $(i, j)$ å·²ç»è¢«å¡«å……ï¼Œåˆ™ç›´æŽ¥é€’å½’åˆ°ä¸‹ä¸€ä¸ªä½ç½® $(i, j + 1)$ã€‚
- å¦åˆ™ï¼Œæˆ‘ä»¬æžšä¸¾å½“å‰ä½ç½® $(i, j)$ å¯ä»¥å¡«å……çš„æœ€å¤§æ­£æ–¹å½¢çš„è¾¹é•¿ $w$ï¼Œå¹¶å°†å½“å‰ä½ç½® $(i, j)$ åˆ° $(i + w - 1, j + w - 1)$ çš„ä½ç½®å…¨éƒ¨å¡«å……ï¼Œç„¶åŽé€’å½’åˆ°ä¸‹ä¸€ä¸ªä½ç½® $(i, j + w)$ã€‚åœ¨å›žæº¯æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†å½“å‰ä½ç½® $(i, j)$ åˆ° $(i + w - 1, j + w - 1)$ çš„ä½ç½®å…¨éƒ¨æ¸…ç©ºã€‚

ç”±äºŽæ¯ä¸ªä½ç½®åªæœ‰ä¸¤ç§çŠ¶æ€ï¼šå¡«å……æˆ–è€…æœªå¡«å……ï¼Œå› æ­¤æˆ‘ä»¬å¯ä»¥ä½¿ç”¨ä¸€ä¸ªæ•´æ•°æ¥è¡¨ç¤ºå½“å‰ä½ç½®çš„çŠ¶æ€ã€‚æˆ‘ä»¬ä½¿ç”¨ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•´æ•°æ•°ç»„ $filled$ï¼Œå…¶ä¸­ $filled[i]$ è¡¨ç¤ºç¬¬ $i$ è¡Œçš„çŠ¶æ€ã€‚å¦‚æžœ $filled[i]$ çš„ç¬¬ $j$ ä½ä¸º $1$ï¼Œåˆ™è¡¨ç¤ºç¬¬ $i$ è¡Œç¬¬ $j$ åˆ—å·²ç»è¢«å¡«å……ï¼Œå¦åˆ™è¡¨ç¤ºæœªå¡«å……ã€‚

* [sol1-Python3]

```python
class Solution:
    def tilingRectangle(self, n: int, m: int) -> int:
        def dfs(i: int, j: int, t: int):
            nonlocal ans
            if j == m:
                i += 1
                j = 0
            if i == n:
                ans = t
                return
            if filled[i] >> j & 1:
                dfs(i, j + 1, t)
            elif t + 1 < ans:
                r = c = 0
                for k in range(i, n):
                    if filled[k] >> j & 1:
                        break
                    r += 1
                for k in range(j, m):
                    if filled[i] >> k & 1:
                        break
                    c += 1
                mx = r if r < c else c
                for w in range(1, mx + 1):
                    for k in range(w):
                        filled[i + w - 1] |= 1 << (j + k)
                        filled[i + k] |= 1 << (j + w - 1)
                    dfs(i, j + w, t + 1)
                for x in range(i, i + mx):
                    for y in range(j, j + mx):
                        filled[x] ^= 1 << y

        ans = n * m
        filled = [0] * n
        dfs(0, 0, 0)
        return ans
```

* [sol1-Java]

```java
class Solution {
    private int n;
    private int m;
    private int[] filled;
    private int ans;

    public int tilingRectangle(int n, int m) {
        this.n = n;
        this.m = m;
        ans = n * m;
        filled = new int[n];
        dfs(0, 0, 0);
        return ans;
    }

    private void dfs(int i, int j, int t) {
        if (j == m) {
            ++i;
            j = 0;
        }
        if (i == n) {
            ans = t;
            return;
        }
        if ((filled[i] >> j & 1) == 1) {
            dfs(i, j + 1, t);
        } else if (t + 1 < ans) {
            int r = 0, c = 0;
            for (int k = i; k < n; ++k) {
                if ((filled[k] >> j & 1) == 1) {
                    break;
                }
                ++r;
            }
            for (int k = j; k < m; ++k) {
                if ((filled[i] >> k & 1) == 1) {
                    break;
                }
                ++c;
            }
            int mx = Math.min(r, c);
            for (int w = 1; w <= mx; ++w) {
                for (int k = 0; k < w; ++k) {
                    filled[i + w - 1] |= 1 << (j + k);
                    filled[i + k] |= 1 << (j + w - 1);
                }
                dfs(i, j + w, t + 1);
            }
            for (int x = i; x < i + mx; ++x) {
                for (int y = j; y < j + mx; ++y) {
                    filled[x] ^= 1 << y;
                }
            }
        }
    }
}
```

* [sol1-C++]

```cpp
class Solution {
public:
    int tilingRectangle(int n, int m) {
        memset(filled, 0, sizeof(filled));
        this->n = n;
        this->m = m;
        ans = n * m;
        dfs(0, 0, 0);
        return ans;
    }

private:
    int filled[13];
    int n, m;
    int ans;

    void dfs(int i, int j, int t) {
        if (j == m) {
            ++i;
            j = 0;
        }
        if (i == n) {
            ans = t;
            return;
        }
        if (filled[i] >> j & 1) {
            dfs(i, j + 1, t);
        } else if (t + 1 < ans) {
            int r = 0, c = 0;
            for (int k = i; k < n; ++k) {
                if (filled[k] >> j & 1) {
                    break;
                }
                ++r;
            }
            for (int k = j; k < m; ++k) {
                if (filled[i] >> k & 1) {
                    break;
                }
                ++c;
            }
            int mx = min(r, c);
            for (int w = 1; w <= mx; ++w) {
                for (int k = 0; k < w; ++k) {
                    filled[i + w - 1] |= 1 << (j + k);
                    filled[i + k] |= 1 << (j + w - 1);
                }
                dfs(i, j + w, t + 1);
            }
            for (int x = i; x < i + mx; ++x) {
                for (int y = j; y < j + mx; ++y) {
                    filled[x] ^= 1 << y;
                }
            }
        }
    }
};
```

* [sol1-Go]

```go
func tilingRectangle(n int, m int) int {
	ans := n * m
	filled := make([]int, n)
	var dfs func(i, j, t int)
	dfs = func(i, j, t int) {
		if j == m {
			i++
			j = 0
		}
		if i == n {
			ans = t
			return
		}
		if filled[i]>>j&1 == 1 {
			dfs(i, j+1, t)
		} else if t+1 < ans {
			var r, c int
			for k := i; k < n; k++ {
				if filled[k]>>j&1 == 1 {
					break
				}
				r++
			}
			for k := j; k < m; k++ {
				if filled[i]>>k&1 == 1 {
					break
				}
				c++
			}
			mx := min(r, c)
			for w := 1; w <= mx; w++ {
				for k := 0; k < w; k++ {
					filled[i+w-1] |= 1 << (j + k)
					filled[i+k] |= 1 << (j + w - 1)
				}
				dfs(i, j+w, t+1)
			}
			for x := i; x < i+mx; x++ {
				for y := j; y < j+mx; y++ {
					filled[x] ^= 1 << y
				}
			}
		}
	}
	dfs(0, 0, 0)
	return ans
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```

* [sol1-TypeScript]

```ts
function tilingRectangle(n: number, m: number): number {
    let ans = n * m;
    const filled: number[] = new Array(n).fill(0);
    const dfs = (i: number, j: number, t: number) => {
        if (j === m) {
            ++i;
            j = 0;
        }
        if (i === n) {
            ans = t;
            return;
        }
        if ((filled[i] >> j) & 1) {
            dfs(i, j + 1, t);
        } else if (t + 1 < ans) {
            let [r, c] = [0, 0];
            for (let k = i; k < n; ++k) {
                if ((filled[k] >> j) & 1) {
                    break;
                }
                ++r;
            }
            for (let k = j; k < m; ++k) {
                if ((filled[i] >> k) & 1) {
                    break;
                }
                ++c;
            }
            const mx = Math.min(r, c);
            for (let w = 1; w <= mx; ++w) {
                for (let k = 0; k < w; ++k) {
                    filled[i + w - 1] |= 1 << (j + k);
                    filled[i + k] |= 1 << (j + w - 1);
                }
                dfs(i, j + w, t + 1);
            }
            for (let x = i; x < i + mx; ++x) {
                for (let y = j; y < j + mx; ++y) {
                    filled[x] ^= 1 << y;
                }
            }
        }
    };
    dfs(0, 0, 0);
    return ans;
}
```

---

æœ‰ä»»ä½•é—®é¢˜ï¼Œæ¬¢è¿Žè¯„è®ºåŒºäº¤æµï¼Œæ¬¢è¿Žè¯„è®ºåŒºæä¾›å…¶å®ƒè§£é¢˜æ€è·¯ï¼ˆä»£ç ï¼‰ï¼Œä¹Ÿå¯ä»¥ç‚¹ä¸ªèµžæ”¯æŒä¸€ä¸‹ä½œè€…å“ˆðŸ˜„~
